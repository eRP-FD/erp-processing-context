/*
 * (C) Copyright IBM Deutschland GmbH 2021
 * (C) Copyright IBM Corp. 2021
 */

#include "erp/hsm/HsmSession.hxx"

#include "erp/crypto/EllipticCurve.hxx"
#include "erp/crypto/EllipticCurveUtils.hxx"
#include "erp/hsm/BlobCache.hxx"
#include "erp/service/VauRequestHandler.hxx"
#include "erp/util/Base64.hxx"
#include "erp/util/TLog.hxx"

#include "mock/crypto/MockCryptography.hxx"
#include "mock/hsm/HsmMockClient.hxx"
#include "mock/hsm/HsmMockFactory.hxx"
#include "mock/hsm/MockBlobCache.hxx"
#include "mock/tpm/TpmTestData.hxx"

#include "test/util/BlobDatabaseHelper.hxx"
#include "test/util/EnvironmentVariableGuard.hxx"
#include "test/util/HsmTestBase.hxx"
#include "test/mock/MockBlobDatabase.hxx"

#if ! defined(__APPLE__) && ! defined(_WINNT_)
    #include "erp/hsm/production/TeeTokenProductionUpdater.hxx"
    #include "erp/hsm/production/HsmProductionFactory.hxx"
    #include "erp/hsm/production/HsmProductionClient.hxx"
#endif

#include <functional>
#include <gtest/gtest.h>
#include <hsmclient/ERP_Error.h>

class ParameterSet
{
public:
    std::shared_ptr<BlobCache> blobCache;
    std::shared_ptr<HsmFactory> factory;
    std::shared_ptr<HsmSession> session;
    std::string name;
    bool enabled{};
    MockBlobCache::MockTarget target{};
};
using ParameterSetFactory = std::function<ParameterSet(void)>;

class HsmSessionTest : public testing::TestWithParam<ParameterSetFactory>
{
public:
    void SetUp (void) override
    {
        parameters = GetParam()();
        if ( ! parameters.enabled)
            GTEST_SKIP();
    }

    void TearDown() override
    {
        if (parameters.enabled)
            BlobDatabaseHelper::removeUnreferencedBlobs();
    }

    ParameterSet parameters;
};

namespace
{
    ParameterSetFactory createSimulatedParameterSetFactory (void)
    {
        ParameterSet parameters;

        if (HsmTestBase::isHsmSimulatorSupportedAndConfigured())
        {
            return []
            {
                ParameterSet parameters;

                parameters.name = "simulated";
                BlobDatabaseHelper::removeUnreferencedBlobs();
                parameters.blobCache = MockBlobDatabase::createBlobCache(MockBlobCache::MockTarget::SimulatedHsm);
                parameters.factory = std::make_unique<HsmProductionFactory>(
                    std::make_unique<HsmProductionClient>(),
                    parameters.blobCache);
                parameters.session = parameters.factory->connect();
                parameters.enabled = true;
                parameters.target = MockBlobCache::MockTarget::SimulatedHsm;

                // Run the tee token updater once, now, so that we have a valid Tee token.
                TeeTokenUpdater::createProductionTeeTokenUpdaterFactory()
                    (
                        [&](ErpBlob&& blob)
                        {
                          parameters.session->setTeeToken(blob);
                        },
                        *parameters.factory,
                        std::make_shared<Timer>()
                    )->update();

                return parameters;
            };
        }
        else
        {
            return []
            {
                ParameterSet parameters;
                parameters.enabled = false;
                return parameters;
            };
        }
    }

    ParameterSetFactory createMockedParameterSetFactory (void)
    {
        return []
        {
            ParameterSet parameters;
            parameters.name = "mocked";
            BlobDatabaseHelper::removeUnreferencedBlobs();
            parameters.blobCache = MockBlobDatabase::createBlobCache(MockBlobCache::MockTarget::MockedHsm);
            parameters.factory = std::make_unique<HsmMockFactory>(
                std::make_unique<HsmMockClient>(),
                parameters.blobCache);
            parameters.session = parameters.factory->connect();
            parameters.enabled = true;
            parameters.target = MockBlobCache::MockTarget::MockedHsm;
            return parameters;
        };
    }

    BlobId getIdForBlob (const ParameterSet& parameters, const BlobType blobType)
    {
        const auto entry = parameters.blobCache->getBlob(blobType);
        return entry.id;
    }
}


TEST_P(HsmSessionTest, create)
{
    HsmMockClient client;
    BlobCache blobCache (std::make_unique<MockBlobDatabase>());

    ASSERT_NO_THROW(
        HsmSession(
            client,
            blobCache,
            std::shared_ptr<HsmRawSession>() // not used for mock
        ));
}


TEST_P(HsmSessionTest, deriveTaskKey_first)
{
    // Task keys are set up by MockBlobCache.

    const auto input = ErpVector::create("hello");
    const auto response = parameters.session->deriveTaskPersistenceKey(
        input,
        {}); // initial call, salt will be generated by hsm, generation id will be supplied by HsmContext.

    // There is nothing we can verify about the returned key.
    // Its data structure guarantees that it exists and has the right length. Its content is entirely unspecified.

    // Verify that salt and generation are set.
    ASSERT_TRUE(response.optionalData.has_value());
    ASSERT_FALSE(response.optionalData->salt.empty());
}




TEST_P(HsmSessionTest, deriveTaskKey_second)
{
    const auto taskId = getIdForBlob(parameters, BlobType::TaskKeyDerivation);
    const auto input = ErpVector::create("hello");
    const auto response = parameters.session->deriveTaskPersistenceKey(
        input,
        OptionalDeriveKeyData{ // Not the initial call, simulate salt and generation id.
            ErpVector::create("the salt"),
            taskId
        });

    // There is nothing we can verify about the returned key.
    // Its data structure guarantees that it exists and has the right length. Its content is entirely unspecified.

    // Verify that salt and generation are empty, i.e. have not been redefined.
    ASSERT_FALSE(response.optionalData.has_value());
}


TEST_P(HsmSessionTest, deriveCommunicationKey_first)
{
    const auto input = ErpVector::create("hello");
    const auto response = parameters.session->deriveCommunicationPersistenceKey(
        input,
        {}); // initial call, salt will be generated by hsm, generation id will be supplied by HsmContext.

    // There is nothing we can verify about the returned key.
    // Its data structure guarantees that it exists and has the right length. Its content is entirely unspecified.

    // Verify that salt and generation are set.
    ASSERT_TRUE(response.optionalData.has_value());
    ASSERT_FALSE(response.optionalData->salt.empty());
}




TEST_P(HsmSessionTest, deriveCommunicationKey_second)
{
    const auto id = getIdForBlob(parameters, BlobType::CommunicationKeyDerivation);
    const auto input = ErpVector::create("hello");
    const auto response = parameters.session->deriveCommunicationPersistenceKey(
        input,
        OptionalDeriveKeyData{ // Not the initial call, simulate salt and generation id.
            ErpVector::create("the salt"),
            id
        });

    // There is nothing we can verify about the returned key.
    // Its data structure guarantees that it exists and has the right length. Its content is entirely unspecified.

    // Verify that salt and generation are empty, i.e. have not been redefined.
    ASSERT_FALSE(response.optionalData.has_value());
}

TEST_P(HsmSessionTest, deriveCommunicationOrTaskKey)//NOLINT(readability-function-cognitive-complexity)
{
    BlobDatabase::Entry taskEntry;
    taskEntry.type = BlobType::TaskKeyDerivation;
    taskEntry.name = ErpVector::create("task key");
    taskEntry.blob = ErpBlob("task derivation key", 1);
    const auto taskId = parameters.blobCache->storeBlob(std::move(taskEntry));

    const auto input = ErpVector::create("hello");
    EXPECT_NO_THROW(parameters.session->deriveCommunicationPersistenceKey(
        input,
        OptionalDeriveKeyData{// Not the initial call, simulate salt and blob id.
                              ErpVector::create("the salt"), taskId}));

    BlobDatabase::Entry communicationEntry;
    communicationEntry.type = BlobType::CommunicationKeyDerivation;
    communicationEntry.name = ErpVector::create("communication key");
    communicationEntry.blob = ErpBlob("communication derivation key", 1);
    const auto communicationId = parameters.blobCache->storeBlob(std::move(communicationEntry));

    EXPECT_NO_THROW(parameters.session->deriveCommunicationPersistenceKey(
        input,
        OptionalDeriveKeyData{// Not the initial call, simulate salt and blob id.
                              ErpVector::create("the salt"), communicationId}));

    BlobDatabase::Entry auditEntry;
    auditEntry.type = BlobType::AuditLogKeyDerivation;
    auditEntry.name = ErpVector::create("audit key");
    auditEntry.blob = ErpBlob("audit log derivation key", 1);
    const auto auditId = parameters.blobCache->storeBlob(std::move(auditEntry));

    {
        // Make sure a task key derived via the communication call has the same result as a regular task key.
        // This is necessary to make old communication entries usable.
        const auto taskDerivation = parameters.session->deriveTaskPersistenceKey(
            input,
            OptionalDeriveKeyData{// Not the initial call, simulate salt and blob id.
                                  ErpVector::create("the salt"), taskId});
        const auto communicationDerivation = parameters.session->deriveCommunicationPersistenceKey(
            input,
            OptionalDeriveKeyData{// Not the initial call, simulate salt and blob id.
                                  ErpVector::create("the salt"), taskId});

        EXPECT_EQ(taskDerivation.derivedKey, communicationDerivation.derivedKey);
    }

    EXPECT_THROW(parameters.session->deriveCommunicationPersistenceKey(
                     input,
                     OptionalDeriveKeyData{// Not the initial call, simulate salt and blob id.
                                           ErpVector::create("the salt"), auditId}),
                 ErpException);
}

TEST_P(HsmSessionTest, differentDerivations)
{
    BlobDatabase::Entry taskEntry;
    taskEntry.type = BlobType::TaskKeyDerivation;
    taskEntry.name = ErpVector::create("task key");
    taskEntry.blob = ErpBlob("derivation key", 1);
    const auto taskId = parameters.blobCache->storeBlob(std::move(taskEntry));

    BlobDatabase::Entry communicationEntry;
    communicationEntry.type = BlobType::CommunicationKeyDerivation;
    communicationEntry.name = ErpVector::create("communication key");
    communicationEntry.blob = ErpBlob("derivation key", 1);
    const auto communicationId = parameters.blobCache->storeBlob(std::move(communicationEntry));

    BlobDatabase::Entry auditEntry;
    auditEntry.type = BlobType::AuditLogKeyDerivation;
    auditEntry.name = ErpVector::create("audit key");
    auditEntry.blob = ErpBlob("derivation key", 1);
    const auto auditId = parameters.blobCache->storeBlob(std::move(auditEntry));

    const auto input = ErpVector::create("hello");

    const auto taskDerivation = parameters.session->deriveTaskPersistenceKey(
        input,
        OptionalDeriveKeyData{// Not the initial call, simulate salt and blob id.
                              ErpVector::create("the salt"), taskId});

    const auto communicationDerivation = parameters.session->deriveCommunicationPersistenceKey(
        input,
        OptionalDeriveKeyData{// Not the initial call, simulate salt and blob id.
                              ErpVector::create("the salt"), communicationId});

    EXPECT_NE(taskDerivation.derivedKey, communicationDerivation.derivedKey);

    const auto auditDerivation = parameters.session->deriveAuditLogPersistenceKey(
        input,
        OptionalDeriveKeyData{// Not the initial call, simulate salt and blob id.
                              ErpVector::create("the salt"), auditId});

    EXPECT_NE(taskDerivation.derivedKey, auditDerivation.derivedKey);
}

TEST_P(HsmSessionTest, deriveAuditLogKey_first)
{
    const auto input = ErpVector::create("hello");
    const auto response = parameters.session->deriveAuditLogPersistenceKey(
        input,
        {}); // initial call, salt will be generated by hsm, generation id will be supplied by HsmContext.

    // There is nothing we can verify about the returned key.
    // Its data structure guarantees that it exists and has the right length. Its content is entirely unspecified.

    // Verify that salt and generation are set.
    ASSERT_TRUE(response.optionalData.has_value());
    ASSERT_FALSE(response.optionalData->salt.empty());
}


TEST_P(HsmSessionTest, deriveAuditLogKey_second)
{
    const auto id = getIdForBlob(parameters, BlobType::AuditLogKeyDerivation);
    const auto input = ErpVector::create("hello");
    const auto response = parameters.session->deriveAuditLogPersistenceKey(
        input,
        OptionalDeriveKeyData{ // Not the initial call, simulate salt and generation id.
            ErpVector::create("the salt"),
            id
        });

    // There is nothing we can verify about the returned key.
    // Its data structure guarantees that it exists and has the right length. Its content is entirely unspecified.

    // Verify that salt and generation are empty, i.e. have not been redefined.
    ASSERT_FALSE(response.optionalData.has_value());
}


TEST_P(HsmSessionTest, getRandomBytes_success)
{
    const auto data = parameters.session->getRandomData(320);
    ASSERT_EQ(data.size(), 320);
}


TEST_P(HsmSessionTest, getRandomBytes_failForTooManyRequestedBytes)
{
    ASSERT_ANY_THROW(parameters.session->getRandomData(321));
}


TEST_P(HsmSessionTest, vauEcies128_forSimulatedHsm)
{
    // This test will verify that the ECIES key derivation via diffie-hellman works.
    // 1. In order to do that it will produce a ephemeral private/public key pair that represents the key of the client.
    // 2. Then it will call the vauEcies128 for the public key of that ephemeral key pair.
    // 3. After that we will run the dh algorithm explicitly for the client side and verify that the resulting AES128 key
    // 4. is identical to the one returned by the HSM.

    // 1. Create an ephemeral key pair for the client.
    const auto clientKeyPair = EllipticCurve::BrainpoolP256R1->createKeyPair();

    // 2. Call the HSM's vauEcies128 function.
    const std::string& publicKeyString = EllipticCurveUtils::publicKeyToX962Der(clientKeyPair);
    const auto serverSymmetricKey = parameters.session->vauEcies128(ErpVector::create(publicKeyString));

    // Symmetric AES keys don't have a structure that can be verified.
    // Just check its length.
    ASSERT_EQ(serverSymmetricKey.size(), Aes128Length);
}


TEST_P(HsmSessionTest, getVauSigPrivateKey)
{
    shared_EVP_PKEY cachedKey{};
    ErpBlob cachedBlob{};
    const auto [privateKey, blob] = parameters.session->getVauSigPrivateKey(cachedKey, cachedBlob);

    ASSERT_NE(privateKey, nullptr);
    ASSERT_NE(blob, ErpBlob{});
}


TEST_P(HsmSessionTest, getVauSigPrivateKey_failForInvalidBlob)
{
    std::vector<uint8_t> invalid = { 0x00, 0x01, 0x02, 0x03 };
    BlobDatabase::Entry entry;
    entry.type = BlobType::VauSig;
    entry.name = ErpVector::create("vausig private key");
    entry.blob = ErpBlob(std::move(invalid), 2);
    parameters.blobCache->storeBlob(std::move(entry));

    shared_EVP_PKEY cachedKey{};
    ErpBlob cachedBlob{};
    ASSERT_ANY_THROW(
        parameters.session->getVauSigPrivateKey(cachedKey, cachedBlob));
}

TEST_P(HsmSessionTest, getVauSigPrivateKeyCached)
{
    shared_EVP_PKEY cachedKey{};
    ErpBlob cachedBlob{};
    std::tie(cachedKey, cachedBlob) = parameters.session->getVauSigPrivateKey(cachedKey, cachedBlob);

    ASSERT_NE(cachedKey, nullptr);
    ASSERT_NE(cachedBlob, ErpBlob{});

    const auto [privateKey, blob] = parameters.session->getVauSigPrivateKey(cachedKey, cachedBlob);
    ASSERT_EQ(cachedKey, privateKey);
    ASSERT_EQ(cachedBlob, blob);
}


TEST_P(HsmSessionTest, getVauSigPrivateKeyNotCached)//NOLINT(readability-function-cognitive-complexity)
{
    if (parameters.name == "simulated")
    {
        GTEST_SKIP();
    }
    shared_EVP_PKEY cachedKey{};
    ErpBlob cachedBlob{};
    std::tie(cachedKey, cachedBlob) = parameters.session->getVauSigPrivateKey(cachedKey, cachedBlob);

    ASSERT_NE(cachedKey, nullptr);
    ASSERT_NE(cachedBlob, ErpBlob{});

    BlobDatabase::Entry entry;
    entry.type = BlobType::VauSig;
    entry.name = ErpVector::create("vau-osig");
    std::string pkey = "-----BEGIN PRIVATE KEY-----\nMIGIAgEAMBQGByqGSM49AgEGCSskAwMCCAEBCARtMGsCAQEEICYfRlJuQlVJx5KB\nhr8nzziMsmaDug1Y29KqQ1Hnb59goUQDQgAEAbRby7L918RBdr8hYHY39tlyJNlN\nfhiaRddfr2nvtic2O0SxYqpzt1OQcysb+vh0XpOf+Cij9SszRH5cpCG5ng==\n-----END PRIVATE KEY-----";
    entry.blob = ErpBlob(std::string_view(MockCryptography::pemToPkcs8(SafeString{std::move(pkey)})), 20);
    entry.certificate = tpm::vauSigCertificate_base64;
    parameters.blobCache->storeBlob(std::move(entry));

    const auto [privateKey, blob] = parameters.session->getVauSigPrivateKey(cachedKey, cachedBlob);
    ASSERT_NE(cachedKey, privateKey);
    ASSERT_NE(cachedBlob, blob);

    std::tie(cachedKey, cachedBlob) = parameters.session->getVauSigPrivateKey(privateKey, blob);
    ASSERT_EQ(cachedKey, privateKey);
    ASSERT_EQ(cachedBlob, blob);
}


TEST_P(HsmSessionTest, unwrapKvnrHashKey)
{
    // Call the session to unwrap (which is a no-op for the HsmMockClient) the HMAC hash key.
    const auto key = parameters.session->getKvnrHmacKey();

    ASSERT_EQ(key.size(), Aes256Length);
}


TEST_P(HsmSessionTest, unwrapTelematikIdHashKey)
{
    // Call the session to unwrap (which is a no-op for the HsmMockClient) the HMAC hash key.
    const auto key = parameters.session->getTelematikIdHmacKey();

    ASSERT_EQ(key.size(), Aes256Length);
}


TEST_P(HsmSessionTest, getLatestTaskPersistenceId)
{
    // Store two blobs for task key derivation.
    // Note that the numbers are the generation ids but that the "latest" blob is determined via its blob id which
    // is based on the order in which the blobs are stored.
    BlobDatabase::Entry entry7;
    entry7.type = BlobType::TaskKeyDerivation;
    entry7.name = ErpVector::create("task key 7");
    entry7.blob = ErpBlob("task derivation key", 7);
    const auto id7 = parameters.blobCache->storeBlob(std::move(entry7));
    BlobDatabase::Entry entry1;
    entry1.type = BlobType::TaskKeyDerivation;
    entry1.name = ErpVector::create("task key 1");
    entry1.blob = ErpBlob("task derivation key", 1);
    const auto id1 = parameters.blobCache->storeBlob(std::move(entry1));

    const auto latestId = parameters.session->getLatestTaskPersistenceId();

    ASSERT_EQ(latestId, id1);
    ASSERT_NE(latestId, id7);
}


TEST_P(HsmSessionTest, getLatestCommunicationPersistenceId)
{
    // Store two blobs for task key derivation.
    // Note that the numbers are the generation ids but that the "latest" blob is determined via its blob id which
    // is based on the order in which the blobs are stored.
    BlobDatabase::Entry entry7;
    entry7.type = BlobType::CommunicationKeyDerivation;
    entry7.name = ErpVector::create("communication key 7");
    entry7.blob = ErpBlob("communication derivation key", 7);
    const auto id7 = parameters.blobCache->storeBlob(std::move(entry7));
    BlobDatabase::Entry entry1;
    entry1.type = BlobType::CommunicationKeyDerivation;
    entry1.name = ErpVector::create("communication key 1");
    entry1.blob = ErpBlob("communication derivation key", 1);
    const auto id1 = parameters.blobCache->storeBlob(std::move(entry1));

    const auto latestId = parameters.session->getLatestCommunicationPersistenceId();

    ASSERT_EQ(latestId, id1);
    ASSERT_NE(latestId, id7);
}


TEST_P(HsmSessionTest, getLatestTaskAuditLogId)
{
    // Store two blobs for audit log key derivation.
    // Note that the numbers are the generation ids but that the "latest" blob is determined via its blob id which
    // is based on the order in which the blobs are stored.
    BlobDatabase::Entry entry7;
    entry7.type = BlobType::AuditLogKeyDerivation;
    entry7.name = ErpVector::create("audit log key 7");
    entry7.blob = ErpBlob("audit log derivation key", 7);
    const auto id7 = parameters.blobCache->storeBlob(std::move(entry7));
    BlobDatabase::Entry entry1;
    entry1.type = BlobType::AuditLogKeyDerivation;
    entry1.name = ErpVector::create("audit log key 1");
    entry1.blob = ErpBlob("audit log derivation key", 1);
    const auto id1 = parameters.blobCache->storeBlob(std::move(entry1));

    const auto latestId = parameters.session->getLatestAuditLogPersistenceId();

    ASSERT_EQ(latestId, id1);
    ASSERT_NE(latestId, id7);
}


class UnparameterizedHsmSessionTest : public testing::Test
{
};
namespace {
    class HsmSessionTestClient : public HsmMockClient
    {
    public:
        std::atomic_size_t callCount = 0;
        ErpVector getRndBytes(const HsmRawSession&, size_t) override
        {
            ++callCount;
            return {};
        }
    };
}


/**
 * The keep alive feature is implemented entirely on the processing context side. Therefore a test with a "real" HSM
 * is not required.
 */
TEST_F(UnparameterizedHsmSessionTest, keepAlive)
{
    auto client = std::make_unique<HsmSessionTestClient>();
    auto blobCache = MockBlobDatabase::createBlobCache(MockBlobCache::MockTarget::MockedHsm);
    auto session = HsmSession(*client, *blobCache, std::shared_ptr<HsmRawSession>());

    // Call getRndBytes (via the session object) to set the lastHsmCall time.
    session.getRandomData(0);
    ASSERT_EQ(client->callCount, 1u);

    // Call keepAlive with a threshold that triggers a keep alive action.
    // In a real world use the offset from now would be negative (in the past). The offset here is an upper bound
    // on the expected error of the timer rather than the timeout of the HSM.
    session.keepAlive(std::chrono::system_clock::now() + std::chrono::seconds(1));

    ASSERT_EQ(client->callCount, 2u);
}

TEST_F(UnparameterizedHsmSessionTest, throwsHsmException)
{
    auto blobCache = MockBlobDatabase::createBlobCache(MockBlobCache::MockTarget::MockedHsm);
    class TestClient : public HsmMockClient
    {
    public:
        ErpVector getRndBytes(const HsmRawSession&, size_t) override
        {
            throw HsmException{"Test Exception", ERP_ERR_NO_CONNECTION};
        }
    };
    TestClient client;
    HsmSession session{client, *blobCache, std::shared_ptr<HsmRawSession>()};
    ASSERT_THROW(session.getRandomData(0), HsmException);
}

INSTANTIATE_TEST_SUITE_P(
    SimulatedHsm,
    HsmSessionTest,
    testing::Values(createSimulatedParameterSetFactory()),
    [](auto&){return "simulated";});

INSTANTIATE_TEST_SUITE_P(
    MockedHsm,
    HsmSessionTest,
    testing::Values(createMockedParameterSetFactory()),
    [](auto&){return "mocked";});
