#!/usr/bin/env python3
#
# (C) Copyright IBM Deutschland GmbH 2021, 2023
# (C) Copyright IBM Corp. 2021, 2023
#
# non-exclusively licensed to gematik GmbH
#
# This script recreates the file src/erp/client/RootCertificates.hxx.
#
# It follows this architectural decision:
# https://gcloud.rth-de.ihost.com/confluence/pages/viewpage.action?pageId=53941117
# Mozilla's wiki page about included certificates:
# https://wiki.mozilla.org/CA/Included_Certificates
# This links to the following CSV file which contains all roots with metadata:
# https://ccadb-public.secure.force.com/mozilla/IncludedCACertificateReportPEMCSV
# ...this is the source of data for this file.

import csv
import os
import urllib.request

filename = os.path.join(os.path.dirname(__file__), '../src/library/client/RootCertificates.hxx')

class CA:
    owner: str
    issuer: str
    common_name: str
    trust_bits: str
    mozilla_constraints: str
    br_audit_url: str
    pem: str

    def __init__(self, csv_row):
        self.owner = csv_row[0]
        self.issuer = csv_row[1]
        self.common_name = csv_row[3]
        self.trust_bits = csv_row[11]
        self.mozilla_constraints = csv_row[21]
        self.br_audit_url = csv_row[27]
        self.pem = csv_row[32].replace("'", '')

    def __str__(self):
        return f'{ca.owner} --- {ca.issuer} --- {ca.common_name}'

    def is_trustworthy(self):
        # - Only allow certificates that apply to websites (not just email)
        # - Completely ignore certificates that Mozilla only trusts for a given region
        allowed_constraints = {'', 'N/A', 'No', 'None'}
        return ('Websites' in self.trust_bits) and (self.mozilla_constraints in allowed_constraints)


root_cas = []
tempfile, _ = urllib.request.urlretrieve('https://ccadb-public.secure.force.com/mozilla/IncludedCACertificateReportPEMCSV')
with open(tempfile) as csvfile:
    certreader = csv.reader(csvfile)
    next(certreader)  # skip headers
    for row in certreader:
        ca = CA(row)
        if ca.is_trustworthy():
            root_cas.append(ca)
        else:
            print(f'Ignoring CA: {ca}')
# Remove all non-trustworthy certificates from the array.
root_cas = [ca for ca in root_cas if ca.is_trustworthy()]


with open(filename, 'w') as output:
    output.write('#ifndef EPA_LIBRARY_CLIENT_ROOTCERTIFICATES_HXX\n')
    output.write('#define EPA_LIBRARY_CLIENT_ROOTCERTIFICATES_HXX\n')
    output.write('\n')
    output.write('#include <string>\n')
    output.write('#include <vector>\n')
    output.write('\n')
    output.write('\n')
    output.write('// This file is based on the Mozilla certificate list.\n')
    output.write('// It is generated by scripts/regenerate_ca_bundle.py => do not modify.\n')
    output.write('\n')
    output.write('inline const std::vector<std::string> rootCertificates{\n')
    for ca in root_cas:
        output.write(f'// {ca}\n')
        output.write(f'R"({ca.pem})"')
        if ca == root_cas[-1]:
            output.write('\n};\n')
        else:
            output.write(',\n')
    output.write('\n')
    output.write('\n')
    output.write('#endif\n')
